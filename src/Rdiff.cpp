#include "Rdiff.h"
#include "InputInterface.h"
#include "OutputInterface.h"
#include <iostream>
#include <vector>
#include "RdiffBuilder.h"

// Running the prepared task. Task is prepared by RdiffBuilder.
void Rdiff::execute() {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start task\n");
    if(!task_) throw std::runtime_error("ERROR: task is not defined");
    task_();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop task\n");
}

// Generating the signature output.
// Hash is generated by the selected rolling hash generator.
// The input and output data can be file or anything else
// what implements the interface's functions. Only file I/O
// implemented in this project.
void Rdiff::generateSignature() {
    // rdiff signature old-file signature-file

    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start signature generation\n");

    if(!input1_->open()) throw std::runtime_error("Cannot open old file");
    if(!output_->open()) throw std::runtime_error("Cannot create signature file");

    hashGenerator_->reset();
    // Signature content has to start with the hash function type.
    saveHashFunctionType();

    // Hash generator reads a full block, and generates and saves its hash value.
    uint8_t c;
    while(input1_->get(c)) {
        hashGenerator_->add(c);
        if(hashGenerator_->isFull()) {
            hashGenerator_->saveHash(output_);
            hashGenerator_->reset();
        }
    }

    output_->flush();
    output_->close();
    input1_->close();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop signature generation\n");
}

void Rdiff::initMatchingClocks() {
    clockA_ = clock_->clone();
    clockU_ = clock_->clone();
    clockFindHash_ = clock_->clone();

    ClockInterface::setTitle(clockA_, "Hash Add");
    ClockInterface::setTitle(clockU_, "Hash Update");
    ClockInterface::setTitle(clockFindHash_, "Find hash");
}

void Rdiff::printMatchingClocksDurations() {
    ClockInterface::printDuration(clockA_);
    ClockInterface::printDuration(clockU_);
    ClockInterface::printDuration(clockFindHash_);
}

// This function tries to find the new file's hash values in the signature content.
// If it is found, a new Chunk will be inserted into chunks_ vector.
void Rdiff::generateChunksForMatchingSignatures() {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start saving chunks for matching signature\n");

    uint8_t c;
    long position{};

    // Mesasuring how much time was spent in some parts of this code.
    // Clock functions do nothing if -s parameter is not used.
    initMatchingClocks();

    // Searching for target file's signatures in the loaded hash values.
    while(input2_->get(c)) {
        if(hashGenerator_->isFull()) {
            ClockInterface::start(clockU_);
            hashGenerator_->update(c);
            ClockInterface::stop(clockU_);
        }
        else {
            ClockInterface::start(clockA_);
            hashGenerator_->add(c);
            ClockInterface::stop(clockA_);
        }
        ++position;
        if(!hashGenerator_->isFull()) continue;

        // calculation of the beginning of the chunk
        long chunkPosition = position - blockSize_;
        // if a chunk has been started, the hash calculation must not stop until the end of the chunk
        if(chunks_.size() && (chunkPosition - chunks_.rbegin()->position <  blockSize_)) continue;

        ClockInterface::start(clockFindHash_);
        auto sigIndex = signatureStorage_->findHash(hashGenerator_.get());
        ClockInterface::stop(clockFindHash_);
        if(sigIndex != signatureStorage_->NOT_FOUND) {
            // If the hash value is among the signatures, the block is probably the same as
            // the corresponding one in the base file
            chunks_.emplace_back(Chunk{chunkPosition, (long)sigIndex, nullptr});
            hashGenerator_->reset();
        }
    }
    printMatchingClocksDurations();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop saving chunks for matching signature\n");
}

void Rdiff::copyContentFromNewFile(long chunkIndex, long from, long length) {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start content copy from new_file\n");
    output_->put(chunkIndex);
    output_->put(length);
    input2_->seek(from);
    if(!input2_->get(copyBuffer_, (size_t)length)) throw std::runtime_error("ERROR: Rdiff::generateDeltaFile input error");
    output_->put(copyBuffer_, (size_t)length);
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop content copy from new_file\n");
}

void Rdiff::copyChunkContentFromNewFile(size_t& chunkIndex, const Chunk& chunk, long input2Size, long& position) {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start chunk content copy from new_file\n");

    if(chunkIndex == 0) {
        // copy the content between 0 file position and the first chunk
        if(chunk.position > 0) {
            // save  hashIndex = partialChunk, length=chunk.position
            // save everything between 0 and (chunk.position - 1)
            copyContentFromNewFile(partialChunk, 0, chunk.position);
        }
    } else {
        if(chunk.position > position) {
            // save  hashIndex = partialChunk, length=chunk.position - position
            // save everythin between position and (chunk.position - 1)
            copyContentFromNewFile(partialChunk, position, chunk.position - position);
        }
    }
    output_->put(chunk.hashIndex);
    position = chunk.position + blockSize_;

    ++chunkIndex;
    if(chunkIndex == chunks_.size() && position < input2Size) {
        // save  hashIndex = partialChunk, length=input2Size - position
        // save everythin between position and  input2Size
        copyContentFromNewFile(partialChunk, position, input2Size - position);
    }
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop chunk content copy from new_file\n");
}

void Rdiff::generateDelta() {
    // rdiff [-v] delta signature-file new-file delta-file

    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start generate delta output\n");

    if(!input2_->open()) throw std::runtime_error("Cannot open new file");
    if(!output_->open()) throw std::runtime_error("Cannot create delta file");

    hashGenerator_->reset();
    // Delta content has to start with the hash function type.
    saveHashFunctionType();

    // Mesasuring of delta generation.
    // Clock functions do nothing if -s parameter is not used.
    ClockInterfaceUPtr clock = clock_->clone();
    ClockInterface::setTitle(clock, "Generate Delta Files");
    ClockInterface::markTime(clock);

    generateChunksForMatchingSignatures();

    ClockInterface::markTime(clock);

    long input2Size = input2_->size();
    long position{};

    for(size_t chunkIndex = 0; auto& chunk : chunks_) {
        copyChunkContentFromNewFile(chunkIndex, chunk, input2Size, position);
    }

    ClockInterface::markTime(clock);

    if((input2Size > 0 && input2Size < blockSize_) || !signatureStorage_->size()) {
        // save  hashIndex = partialChunk, length=input2_->size()
        // save everythin between position and  input2_->size()
        copyContentFromNewFile(partialChunk, 0, input2Size);
    }

    ClockInterface::markTime(clock);

    output_->flush();
    output_->close();
    input2_->close();

    ClockInterface::markTime(clock);
    ClockInterface::printResult(clock);
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop generate delta output\n");
}

// The loaded hash values will be stored in the signatureStorage_.
void Rdiff::loadSignature() {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start load signature\n");

    if(!input1_->open()) throw std::runtime_error("Cannot open signature file");
    changeHashGenerator(input1_);
    signatureStorage_->clear();
    while(signatureStorage_->readHash(input1_.get()));
    input1_->close();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop load signature\n");
}

void Rdiff::loadDelta() {
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start load delta\n");

    if(!input2_->open()) throw std::runtime_error("Cannot open delta file");

    changeHashGenerator(input2_);

    long v;
    long length;
    while(input2_->get(v)) {
        Chunk chunk;
        if(v == partialChunk) {
            // a length should come here
            if(!input2_->get(length) || length <= 0) throw std::runtime_error("Illegal delta file");

            chunk.block = std::make_unique<std::vector<uint8_t>>((size_t)length, 0);
            // read patch content from delta
            if(!input2_->get(*chunk.block, (size_t)length)) throw std::runtime_error("Invalid block length in delta file");

            chunks_.push_back(std::move(chunk));
        } else {
            chunk.hashIndex = v;
            chunks_.push_back(std::move(chunk));
        }
    }
    input2_->close();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop load delta\n");
}

void Rdiff::generatePatchedOutput() {
    // rdiff [-v] patch basis-file delta-file new-file
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "start generate patch output\n");
    if(!input1_->open()) throw std::runtime_error("Cannot open basis file");
    if(!output_->open()) throw std::runtime_error("Cannot create patched file");

    for(auto& chunk : chunks_) {
        if(chunk.hashIndex == partialChunk) {
            output_->put(*chunk.block, chunk.block->size());
        } else {
            input1_->seek(chunk.hashIndex * blockSize_);
            if(!input1_->get(copyBuffer_, blockSize_)) throw std::runtime_error("ERROR: Rdiff::generatePatchedFile input error");
            output_->put(copyBuffer_, blockSize_);
        }
    }

    output_->flush();
    output_->close();
    input1_->close();
    LoggerInterface::log(logger_, __FILE__, __LINE__, "Rdiff", __FUNCTION__, "stop generate patch output\n");
}

void Rdiff::changeHashGenerator(InputInterfaceUPtr& input) {
    uint8_t hashFunctionType;
    if(!input->get(hashFunctionType)) throw std::runtime_error("Wrong hash function type");
    RdiffBuilder::changeHashFunction(this, hashFunctionType);
}

void Rdiff::saveHashFunctionType() {
    output_->put((uint8_t)hashGenerator_->hashFunctionType());
}
